<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Puppet Flyer</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:monospace;background:linear-gradient(#64b5f6,#1976d2);display:flex;justify-content:center;padding:20px}
  .game-container{background:#fff;padding:30px;border-radius:10px;box-shadow:0 10px 40px rgba(0,0,0,.3);max-width:1000px;width:100%}
  #gameCanvas{border:4px solid #333;border-radius:5px;display:block;margin:0 auto;image-rendering:pixelated;max-width:100%;height:auto;touch-action:none;cursor:pointer; background: #000; }
  .controls{text-align:center;margin-top:20px}

  /* small utility */
  .small { font-size:12px; color:#555; margin-top:8px; }

  /* Countdown overlay (minimal, non-invasive) */
  .countdown-overlay {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 30;
  }
  .countdown-number {
    font-family: monospace;
    color: #0CAF0C; /* green matching strings */
    font-size: 96px;
    line-height: 1;
    text-shadow: 0 0 8px rgba(12,175,12,0.35);
    opacity: 0;
    transition: transform 0.28s ease, opacity 0.28s ease;
    transform: translateY(6px) scale(0.98);
    pointer-events: none;
    display:flex;
    align-items:center;
    justify-content:center;
    /* FIX: give the countdown an explicit size so the generated pixel image is visible */
    width: 240px;
    height: 140px;
  }
  /* when the .show class is toggled the number becomes visible */
  .countdown-number.show {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
  /* when the countdown contains an image, force pixel rendering on that image */
  .countdown-number img {
    image-rendering: pixelated;
    display:block;
    max-width:100%;
    max-height:100%;
    width:auto;
    height:auto;
  }

  /* Pixelized game-over container (overlay centered over canvas) */
  .game-over-overlay {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: 50;
    pointer-events: auto;
    background: rgba(0,0,0,0.66);
    padding: 10px 14px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    text-align: center;
    min-width: 220px;
  }
  .game-over-overlay img { image-rendering: pixelated; display:block; max-width:100%; height:auto; }

  /* Instruction text outside the game (minimal) */
  .instructions {
    margin-top: 12px;
    font-weight: 700;
    color: #333;
    display: inline-block;
    background: rgba(255,255,255,0.9);
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 13px;
    letter-spacing: 0.6px;
  }

  /* Responsive (minimal) */
  @media (max-width:680px) {
    .game-container { padding:18px; }
    .countdown-number { width: 160px; height: 96px; }
  }
</style>
</head>
<body>
  <div class="game-container" style="position:relative;">
    <h1 style="text-align:center">
    <img src="spamton.png" alt="logo" style="height:48px; vertical-align:middle; margin-right:10px;" />
    <span style="font-size:28px; vertical-align:middle; font-weight:700;">Puppet Flyer</span>
    <img src="spamton.png" alt="logo" style="height:48px; vertical-align:middle; margin-left:10px;" />
    </h1>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <!-- Countdown overlay (minimal, sits above canvas) -->
    <div class="countdown-overlay" id="countdownOverlay" aria-hidden="true">
    <div id="countdownNumber" class="countdown-number" role="status" aria-live="polite">3</div>
    </div>

    <div id="controls" class="controls"><div class="loading">Loading game assets...</div></div>

    <!-- Instruction text outside the game environment -->
    <div style="text-align:center;">
    <div class="instructions">TO MOVE: Spacebar (Desktop) / Tap (Mobile)</div>
    </div>

  </div>

<script>
/* ==== 
   Asset loading (unchanged)
   ==== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const controlsDiv = document.getElementById('controls');

const characterImage = new Image(); characterImage.src = "string flyer spamton.png";
const robotBoxImage = new Image(); robotBoxImage.src = "robot box.png";
const popUpAdImage = new Image(); popUpAdImage.src = "pop up ad.png";
const spamtonImage = new Image(); spamtonImage.src = "spamton.png";

const asteriskImage = new Image();
let asteriskLoaded = false;
asteriskImage.onload = () => { asteriskLoaded = true; };
asteriskImage.onerror = () => { console.log('Asterisk image not found'); asteriskLoaded = false; };
asteriskImage.src = "pixel-asterisk.png?cb=" + Date.now();

let imageLoaded = false;
characterImage.onload = () => { imageLoaded = true; checkReady(); };
characterImage.onerror = () => { imageLoaded = true; checkReady(); };

function checkReady(){ if (imageLoaded) showWelcomeScreen(); }
function showWelcomeScreen(){
  controlsDiv.innerHTML = `<div style="max-width:400px;margin:0 auto;text-align:center">
    <h2>Welcome to Puppet Flyer!</h2>
    <button onclick="startGameWithCountdown()">START GAME</button>
  </div>`;
}

/* ==== 
   Game state (unchanged)
   ==== */
let liveAsteriskRef = null;
let gameState = {
  started:false, over:false,
  player:{ x:100,y:200,width:80,height:80,velocity:0,pulling:false },
  obstacles:[], explosions:[], score:0,
  highScore: localStorage.getItem('puppetFlyerHighScore') || 0,
  gameSpeed:8, gravity:0.4, pullStrength:-7,
  obstacleTimer:0, asteriskTimer:0, asteriskSpawnStarted:false,
  spinningTimer:0, spawnInterval:80, startTime:0, elapsedTime:0, difficultyLevel:0,
  spamtonTimer:0, spamtonSpawnStarted:false
};

/* Settings used by physics boxes */
const ASTERISK_BASE = 50;
const ASTERISK_SIZE = Math.round(ASTERISK_BASE * 0.85);
const PHYSICS_SHRINK = 0.60;
const ENTERED_MARGIN = 8;
const ENTERED_GRACE_FRAMES = 6;

/* New: shrink factor for stationary obstacle collision boxes (tighten them) */
const OBSTACLE_PHYSICS_SHRINK = 0.78;

/* ==== 
   New: tight bounds per-image/per-size computation & cache
   - computes a tight non-transparent bounding rectangle by drawing
    the image to an offscreen canvas at the spawn width/height and
    scanning alpha channel.
   - returns rect in the same pixel units as the spawn width/height
   - cached by image.src + size so subsequent spawns at same size are instant
   ==== */
const tightBoundsCache = {};
const ALPHA_THRESHOLD = 10; // pixels with alpha > this count as opaque

function computeTightBoundsForImageAtSize(img, width, height){
  if (!img || !img.complete || img.naturalWidth === 0) return null;
  const key = `${img.src}|${width}x${height}`;
  if (tightBoundsCache[key]) return tightBoundsCache[key];

  try {
    const oc = document.createElement('canvas');
    oc.width = Math.max(1, Math.round(width));
    oc.height = Math.max(1, Math.round(height));
    const octx = oc.getContext('2d');
    octx.clearRect(0,0,oc.width,oc.height);
    octx.drawImage(img, 0, 0, oc.width, oc.height);
    const imgData = octx.getImageData(0,0,oc.width,oc.height).data;

    let minX = oc.width, minY = oc.height, maxX = -1, maxY = -1;
    for (let y = 0; y < oc.height; y++){
    for (let x = 0; x < oc.width; x++){
    const idx = (y * oc.width + x) * 4;
    const alpha = imgData[idx + 3];
    if (alpha > ALPHA_THRESHOLD){
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
    }
    }
    }

    if (maxX === -1) {
    const full = { x:0, y:0, width: oc.width, height: oc.height };
    tightBoundsCache[key] = full;
    return full;
    }

    const rect = {
    x: minX,
    y: minY,
    width: (maxX - minX + 1),
    height: (maxY - minY + 1)
    };
    tightBoundsCache[key] = rect;
    return rect;
  } catch (err){
    // getImageData can throw on cross-origin images — fallback to full rect.
    tightBoundsCache[key] = { x:0, y:0, width: Math.round(width), height: Math.round(height) };
    return tightBoundsCache[key];
  }
}

/* Asterisk physics box (unchanged) */
function getAsteriskPhysicsBox(a){
  const padX = (a.width * (1 - PHYSICS_SHRINK)) / 2;
  const padY = (a.height * (1 - PHYSICS_SHRINK)) / 2;
  return { x: a.x + padX, y: a.y + padY, width: a.width - padX*2, height: a.height - padY*2 };
}

/* For stationary obstacles:
   - robotbox and popupad now return exact sprite tight boxes (no extra transparent padding)
   - other obstacles still use tightened physics box
*/
function getObstaclePhysicsBox(obs){
  if (obs.type === 'robotbox' || obs.type === 'popupad') {
    // if tight box already computed for this spawn, use it immediately
    if (obs._tightBox) {
    return {
    x: Math.round(obs.x + obs._tightBox.x),
    y: Math.round(obs.y + obs._tightBox.y),
    width: Math.round(obs._tightBox.width),
    height: Math.round(obs._tightBox.height)
    };
    }
    // attempt on-the-fly compute (if image loaded) and attach
    let img = (obs.type === 'robotbox') ? robotBoxImage : popUpAdImage;
    const tb = computeTightBoundsForImageAtSize(img, Math.round(obs.width), Math.round(obs.height));
    if (tb) {
    obs._tightBox = tb;
    return {
    x: Math.round(obs.x + tb.x),
    y: Math.round(obs.y + tb.y),
    width: Math.round(tb.width),
    height: Math.round(tb.height)
    };
    }
    // fallback: use full sprite rect (previous behavior)
    return { x: Math.round(obs.x), y: Math.round(obs.y), width: Math.round(obs.width), height: Math.round(obs.height) };
  }
  const shrink = OBSTACLE_PHYSICS_SHRINK;
  const padX = (obs.width * (1 - shrink)) / 2;
  const padY = (obs.height * (1 - shrink)) / 2;
  return { x: obs.x + padX, y: obs.y + padY, width: obs.width - padX*2, height: obs.height - padY*2 };
}

/* ==== 
   Hitbox configuration + persistence
   - debug panel allowed tuning before; we keep config & persistence (used for collisions)
   ==== */
const HITBOX_STORAGE_KEY = 'pf_hitbox_config_v1';

// updated defaults (tighter torso/body/head per your screenshot feedback)
const defaultHitboxConfig = {
  head:  { xOffset: 0.30, yOffset: 0.04, width: 0.36, height: 0.18, color: 'rgba(255,100,100,0.25)', stroke: 'rgba(255,100,100,0.95)' },
  torso: { xOffset: 0.26, yOffset: 0.30, width: 0.46, height: 0.32, color: 'rgba(100,200,255,0.25)', stroke: 'rgba(20,120,200,0.95)' },
  legs:  { xOffset: 0.36, yOffset: 0.66, width: 0.28, height: 0.30, color: 'rgba(150,255,150,0.25)', stroke: 'rgba(40,150,60,0.95)' }
};

let hitboxConfig = loadHitboxConfig();

function loadHitboxConfig(){
  try {
    const raw = localStorage.getItem(HITBOX_STORAGE_KEY);
    if (raw) {
    const parsed = JSON.parse(raw);
    return Object.assign({}, defaultHitboxConfig, parsed);
    }
  } catch(e){}
  return JSON.parse(JSON.stringify(defaultHitboxConfig));
}
function saveHitboxConfig(){
  try { localStorage.setItem(HITBOX_STORAGE_KEY, JSON.stringify(hitboxConfig)); } catch(e){}
}
function resetHitboxConfig(){
  hitboxConfig = JSON.parse(JSON.stringify(defaultHitboxConfig));
  saveHitboxConfig();
}

/* NEW: returns two rectangles (torso, legs) — head is intentionally not used for collision per your request */
function getPlayerHitBoxes(){
  const p = gameState.player;
  const w = p.width;
  const h = p.height;

  const cfg = hitboxConfig;

  const torso = {
    x: Math.round(p.x + w * cfg.torso.xOffset),
    y: Math.round(p.y + h * cfg.torso.yOffset),
    width: Math.round(w * cfg.torso.width),
    height: Math.round(h * cfg.torso.height)
  };
  const legs = {
    x: Math.round(p.x + w * cfg.legs.xOffset),
    y: Math.round(p.y + h * cfg.legs.yOffset),
    width: Math.round(w * cfg.legs.width),
    height: Math.round(h * cfg.legs.height)
  };

  return [torso, legs];
}

/* Keep a simple bounding body box for world-edge checks — tightened per feedback
   NOTE: This body box will no longer be used for obstacle collision tests.
*/
function getPlayerBodyBox(){
  const p = gameState.player;
  // reduced overall width & height so the yellow box is less permissive
  const bodyX = Math.round(p.x + p.width * 0.32);
  const bodyY = Math.round(p.y + p.height * 0.18);
  const bodyW = Math.round(p.width * 0.36);
  const bodyH = Math.round(p.height * 0.64);
  return { x: bodyX, y: bodyY, width: bodyW, height: bodyH };
}

/* ==== 
   Drawing functions (player/obstacles/explosions)
   ==== */
function drawPlayer(){
  const p = gameState.player;
  if (characterImage && characterImage.complete && characterImage.naturalWidth>0) ctx.drawImage(characterImage,p.x-8,p.y,p.width,p.height);
  else { ctx.fillStyle='#FF1493'; ctx.fillRect(p.x+15,p.y+10,40,35); }
}
function drawRope(){ const p=gameState.player; const ropeX=p.x+p.width/2; ctx.strokeStyle=p.pulling? '#0A8A0A':'#0CAF0C'; ctx.lineWidth=2; for(let i=-6;i<=6;i+=3){ ctx.beginPath(); ctx.moveTo(ropeX+i,0); ctx.lineTo(ropeX+i,p.y); ctx.stroke(); } ctx.fillStyle='#696969'; ctx.fillRect(ropeX-8,0,16,10); }

/* Obstacle generators now attach computed tight bounds (when possible) */
function generateRobotBoxObstacle(){
  const lower = 60;
  const upper = 95;
  const mid = (lower + upper) / 2;
  const p = Math.random();
  let size;
  if (p < 0.65) {
    size = lower + Math.random() * (mid - lower);
  } else {
    size = mid + Math.random() * (upper - mid);
  }
  size = Math.round(size);
  const y = 50 + Math.random() * Math.max(0, canvas.height - 50 - size);
  const obs = { x:canvas.width, y:y, width:size, height:size, type:'robotbox' };

  // compute tight bounds (if image loaded & same-origin)
  const tb = computeTightBoundsForImageAtSize(robotBoxImage, obs.width, obs.height);
  if (tb) obs._tightBox = tb;

  return obs;
}
function generatePopUpAdObstacle(){ 
  const isTop=Math.random()<0.5; 
  const base=80; 
  const r=Math.random(); 
  const t=Math.min(gameState.elapsedTime/60,1); 
  const skew=Math.pow(r,1 - t*0.5); 
  const lower = 0.75 * 1.2; // 0.9
  const upper = (0.92 * 1.2) * 1.2; // 1.3248
  const size = Math.round(base*(lower + skew*(upper - lower))); 
  const y = isTop ? 0 : (canvas.height - size);
  const obs = { x:canvas.width, y:y, width:size, height:size, type:'popupad' };

  const tb = computeTightBoundsForImageAtSize(popUpAdImage, obs.width, obs.height);
  if (tb) obs._tightBox = tb;

  return obs;
}

function generateAsteriskObstacle(){
  const asteriskSize = ASTERISK_SIZE;
  const marginOut = 10;

  const r = Math.random();
  let spawnEdge;
  if (r < 0.60) {
    spawnEdge = 'right';
  } else if (r < 0.85) {
    spawnEdge = Math.random() < 0.5 ? 'top' : 'bottom';
  } else {
    spawnEdge = 'left';
  }

  let x, y;
  if (spawnEdge === 'left') {
    x = -asteriskSize - marginOut;
    y = Math.random() * (canvas.height - asteriskSize);
  } else if (spawnEdge === 'right') {
    x = canvas.width + asteriskSize + marginOut;
    y = Math.random() * (canvas.height - asteriskSize);
  } else if (spawnEdge === 'top') {
    x = Math.random() * (canvas.width - asteriskSize);
    y = -asteriskSize - marginOut;
  } else {
    x = Math.random() * (canvas.width - asteriskSize);
    y = canvas.height + asteriskSize + marginOut;
  }

  const t = Math.max(gameState.elapsedTime - 16, 0);
  const minSpeedStart = 1.5, maxSpeedStart = 3.0, minSpeedEnd = 4.0, maxSpeedEnd = 7.0;
  const rampDuration = 40;
  const progress = Math.min(t / rampDuration, 1);
  let minSpeed = minSpeedStart + (minSpeedEnd - minSpeedStart)*progress;
  let maxSpeed = maxSpeedStart + (maxSpeedEnd - maxSpeedStart)*progress;
  let speed = minSpeed + Math.random() * (maxSpeed - minSpeed);

  const deg2rad = deg => deg * Math.PI / 180;

  let angle;
  if (spawnEdge === 'right') {
    angle = Math.PI + (Math.random()*2 - 1) * deg2rad(15);
  } else if (spawnEdge === 'left') {
    angle = 0 + (Math.random()*2 - 1) * deg2rad(15);
  } else if (spawnEdge === 'top') {
    angle = Math.PI/2 + (Math.random()*2 - 1) * deg2rad(30);
  } else {
    angle = -Math.PI/2 + (Math.random()*2 - 1) * deg2rad(30);
  }

  if ((spawnEdge === 'top' || spawnEdge === 'bottom') && x > canvas.width / 2) {
    angle = Math.PI + (Math.random()*2 - 1) * deg2rad(20);
    const required = Math.max(gameState.gameSpeed * 1.2, maxSpeed);
    if (speed < required) speed = required;
    maxSpeed = Math.max(maxSpeed, required);
  }

  if (spawnEdge === 'right') {
    const required = Math.max(gameState.gameSpeed * 1.2, maxSpeed);
    if (speed < required) {
    speed = required;
    maxSpeed = Math.max(maxSpeed, required);
    }
  }

  let vx = Math.cos(angle) * speed;
  let vy = Math.sin(angle) * speed;

  if (spawnEdge === 'right' && vx > 0) vx = -Math.abs(vx);
  if (spawnEdge === 'left'  && vx < 0) vx = Math.abs(vx);
  if (spawnEdge === 'top'   && vy < 0) vy = Math.abs(vy);
  if (spawnEdge === 'bottom'&& vy > 0) vy = -Math.abs(vy);

  const typicalSpeed = (minSpeed + maxSpeed) / 2;
  const minHorizontal = Math.max(0.28 * typicalSpeed, 0.4);
  const minVertical = Math.max(0.12 * typicalSpeed, 0.12);

  if (spawnEdge === 'left' || spawnEdge === 'right') {
    if (Math.abs(vx) < minHorizontal) vx = (vx < 0 ? -1 : 1) * minHorizontal;
  } else {
    if (Math.abs(vy) < minVertical) vy = (vy < 0 ? -1 : 1) * minVertical;
  }

  const PAD = 6;
  let timeToVisible = null;

  if (spawnEdge === 'right' && vx !== 0) {
    timeToVisible = (canvas.width - x) / vx;
    if (timeToVisible > 0 && isFinite(timeToVisible)) {
    const predictedY = y + vy * timeToVisible;
    const minY = PAD;
    const maxY = canvas.height - asteriskSize - PAD;
    if (predictedY < minY || predictedY > maxY) {
    const targetY = Math.max(minY, Math.min(maxY, predictedY < minY ? minY : maxY));
    vy = (targetY - y) / timeToVisible;
    }
    }
  } else if (spawnEdge === 'left' && vx !== 0) {
    timeToVisible = (0 - (x + asteriskSize)) / vx;
    if (timeToVisible > 0 && isFinite(timeToVisible)) {
    const predictedY = y + vy * timeToVisible;
    const minY = PAD;
    const maxY = canvas.height - asteriskSize - PAD;
    if (predictedY < minY || predictedY > maxY) {
    const targetY = Math.max(minY, Math.min(maxY, predictedY < minY ? minY : maxY));
    vy = (targetY - y) / timeToVisible;
    }
    }
  } else if (spawnEdge === 'top' && vy !== 0) {
    timeToVisible = (0 - (y + asteriskSize)) / vy;
    if (timeToVisible > 0 && isFinite(timeToVisible)) {
    const predictedX = x + vx * timeToVisible;
    const minX = PAD;
    const maxX = canvas.width - asteriskSize - PAD;
    if (predictedX < minX || predictedX > maxX) {
    const targetX = Math.max(minX, Math.min(maxX, predictedX < minX ? minX : maxX));
    vx = (targetX - x) / timeToVisible;
    if (Math.abs(vx) < minHorizontal) vx = (vx < 0 ? -1 : 1) * minHorizontal;
    }
    }
  } else if (spawnEdge === 'bottom' && vy !== 0) {
    timeToVisible = (canvas.height - y) / vy;
    if (timeToVisible > 0 && isFinite(timeToVisible)) {
    const predictedX = x + vx * timeToVisible;
    const minX = PAD;
    const maxX = canvas.width - asteriskSize - PAD;
    if (predictedX < minX || predictedX > maxX) {
    const targetX = Math.max(minX, Math.min(maxX, predictedX < minX ? minX : maxX));
    vx = (targetX - x) / timeToVisible;
    if (Math.abs(vx) < minHorizontal) vx = (vx < 0 ? -1 : 1) * minHorizontal;
    }
    }
  }

  let intersectionTime = null;
  if (spawnEdge === 'right' && vx !== 0) {
    const targetX = canvas.width - asteriskSize - 1;
    intersectionTime = (targetX - x) / vx;
    if (intersectionTime > 0 && isFinite(intersectionTime)) {
    x = x + vx * intersectionTime;
    y = y + vy * intersectionTime;
    } else {
    x = canvas.width - asteriskSize - 1;
    }
  } else if (spawnEdge === 'left' && vx !== 0) {
    const targetX = 1;
    intersectionTime = (targetX - x) / vx;
    if (intersectionTime > 0 && isFinite(intersectionTime)) {
    x = x + vx * intersectionTime;
    y = y + vy * intersectionTime;
    } else {
    x = 1;
    }
  } else if (spawnEdge === 'top' && vy !== 0) {
    const targetY = 1;
    intersectionTime = (targetY - y) / vy;
    if (intersectionTime > 0 && isFinite(intersectionTime)) {
    x = x + vx * intersectionTime;
    y = y + vy * intersectionTime;
    } else {
    y = 1;
    }
  } else if (spawnEdge === 'bottom' && vy !== 0) {
    const targetY = canvas.height - asteriskSize - 1;
    intersectionTime = (targetY - y) / vy;
    if (intersectionTime > 0 && isFinite(intersectionTime)) {
    x = x + vx * intersectionTime;
    y = y + vy * intersectionTime;
    } else {
    y = canvas.height - asteriskSize - 1;
    }
  }

  x = Math.max(0, Math.min(canvas.width - asteriskSize, x));
  y = Math.max(0, Math.min(canvas.height - asteriskSize, y));

  const preAdvanceSteps = 1;
  x += vx * preAdvanceSteps;
  y += vy * preAdvanceSteps;

  const a = {
    x, y, width: asteriskSize, height: asteriskSize,
    vx, vy,
    type: 'asterisk', rotation: Math.random()*Math.PI*2,
    entered:false, age:1, _remove:false
  };

  return a;
}

/* Spamton generator
   - increased travel speeds: min/max increased by 10%
   - increased spin magnitudes: rotationSpeed multiplied by 1.15 (15% up)
*/
function generateSpamtonObstacle(){
  const size = Math.round(64 * 0.67);
  const marginOut = 12;
  const edges = ['top','right','bottom'];
  const spawnEdge = edges[Math.floor(Math.random()*edges.length)];

  let x, y;
  if (spawnEdge === 'right') {
    x = canvas.width + size + marginOut;
    y = Math.random() * (canvas.height - size);
  } else if (spawnEdge === 'top') {
    const minX = Math.floor(canvas.width * 2 / 3);
    const maxX = canvas.width - size - 1;
    x = minX + Math.random() * Math.max(0, maxX - minX);
    y = -size - marginOut;
  } else {
    const minX = Math.floor(canvas.width * 2 / 3);
    const maxX = canvas.width - size - 1;
    x = minX + Math.random() * Math.max(0, maxX - minX);
    y = canvas.height + size + marginOut;
  }

  const deg2rad = deg => deg * Math.PI / 180;
  let angleDeg;
  if (spawnEdge === 'top') {
    angleDeg = 105 + Math.random() * (165 - 105);
  } else if (spawnEdge === 'right') {
    angleDeg = 165 + Math.random() * (195 - 165);
  } else {
    angleDeg = 195 + Math.random() * (255 - 195);
  }
  const angle = deg2rad(angleDeg);

  // original bands: gameState.gameSpeed * 1.08 and * 1.25 with fallbacks 3.5/5.5
  let minSpeed = Math.max(gameState.gameSpeed * 1.08, 3.5);
  let maxSpeed = Math.max(gameState.gameSpeed * 1.25, 5.5);

  // Increase both min and max by 10%
  minSpeed *= 1.10;
  maxSpeed *= 1.10;

  const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);

  let vx = Math.cos(angle) * speed;
  let vy = Math.sin(angle) * speed;

  if (vx > -Math.abs(gameState.gameSpeed * 0.95)) {
    const chosen = minSpeed + Math.random() * (Math.max(maxSpeed - minSpeed, 0.5));
    vx = -Math.abs(chosen);
    vy = (Math.random() - 0.5) * (Math.abs(chosen) * 0.35);
  }

  if (spawnEdge === 'right') {
    x = canvas.width - size - 1;
  } else if (spawnEdge === 'top') {
    y = 1;
  } else if (spawnEdge === 'bottom') {
    y = canvas.height - size - 1;
  }

  x += vx * 1;
  y += vy * 1;

  const rotation = Math.random()*Math.PI*2;
  // original rotation speed expression preserved but magnified by 15%
  let rotationSpeed = ((Math.random()*0.06 - 0.03) * (0.6 + Math.random()*1.0)) * 2;
  rotationSpeed *= 1.15; // increase spin range by 15%

  const s = {
    x, y, width: size, height: size,
    vx, vy,
    type: 'spamton',
    rotation, rotationSpeed,
    entered:false, age:1, _remove:false
  };

  return s;
}

/* Draw obstacles */
function drawObstacles(){
  gameState.obstacles.forEach(obs=>{
    if (obs.type==='robotbox'){
    if (robotBoxImage && robotBoxImage.complete && robotBoxImage.naturalWidth>0) ctx.drawImage(robotBoxImage, obs.x, obs.y, obs.width, obs.height);
    else { ctx.fillStyle='#FF6B6B'; ctx.fillRect(obs.x,obs.y,obs.width,obs.height); }
    } else if (obs.type==='popupad'){
    if (popUpAdImage && popUpAdImage.complete && popUpAdImage.naturalWidth>0) ctx.drawImage(popUpAdImage, obs.x, obs.y, obs.width, obs.height);
    else { ctx.fillStyle='#9B59B6'; ctx.fillRect(obs.x,obs.y,obs.width,obs.height); }
    } else if (obs.type==='asterisk' || obs.type==='spamton'){
    ctx.save(); ctx.translate(obs.x + obs.width/2, obs.y + obs.height/2); ctx.rotate(obs.rotation);
    if (obs.type==='asterisk') {
    if (asteriskLoaded && asteriskImage.complete && asteriskImage.naturalWidth>0) ctx.drawImage(asteriskImage, -obs.width/2, -obs.height/2, obs.width, obs.height);
    else { ctx.strokeStyle='#FFF'; ctx.lineWidth=4; const s=obs.width/2; ctx.beginPath(); ctx.moveTo(-s,0); ctx.lineTo(s,0); ctx.moveTo(0,-s); ctx.lineTo(0,s); ctx.stroke(); }
    obs.rotation += 0.05;
    } else { // spamton
    if (spamtonImage && spamtonImage.complete && spamtonImage.naturalWidth>0) ctx.drawImage(spamtonImage, -obs.width/2, -obs.height/2, obs.width, obs.height);
    else { ctx.fillStyle='#FFF'; ctx.fillRect(-obs.width/2, -obs.height/2, obs.width, obs.height); }
    obs.rotation += obs.rotationSpeed || 0.03;
    }
    ctx.restore();
    }
  });
}

/* Explosion util */
function createExplosion(x,y){ const particles=[]; for(let i=0;i<12;i++){ const angle=(Math.PI*2*i)/12; particles.push({x,y,vx:Math.cos(angle)*(2+Math.random()*3),vy:Math.sin(angle)*(2+Math.random()*3),life:20+Math.random()*10,maxLife:30}); } gameState.explosions.push({x,y,particles,life:30}); }
function drawExplosions(){ gameState.explosions = gameState.explosions.filter(ex=>{ ex.life--; ex.particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.life--; const alpha = p.life / p.maxLife; const size = 4 * (p.life / p.maxLife); ctx.fillStyle = `rgba(255,215,0,${alpha})`; ctx.fillRect(p.x-size/2,p.y-size/2,size,size); }); return ex.life>0; }); }

/* Rect overlap helper */
function rectsOverlap(a,b){
  return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
}

/* ==== 
   Collision checking — uses configured hitboxes and tightened obstacle boxes
   ==== */
function checkCollision(){
  const body = getPlayerBodyBox(); // for boundary checks only
  const hitBoxes = getPlayerHitBoxes(); // now only torso and legs

  // world top/bottom collision (use overall bounding box)
  if (body.y <= 0 || body.y + body.height >= canvas.height) {
    createExplosion(body.x + body.width/2, body.y + body.height/2);
    return true;
  }

  for (let i=0;i<gameState.obstacles.length;i++){
    const obs = gameState.obstacles[i];

    // Moving "asterisk" or "spamton" use their asterisk physics box
    if (obs.type === 'asterisk' || obs.type === 'spamton') {
    const pb = getAsteriskPhysicsBox(obs);

    // test each puppet hitbox against the physics box
    let collided = false;
    let collidedHitBox = null;
    for (let hb of hitBoxes) {
    if (rectsOverlap(hb, pb)) { collided = true; collidedHitBox = hb; break; }
    }

    if (collided) {
    createExplosion(collidedHitBox.x + collidedHitBox.width/2, collidedHitBox.y + collidedHitBox.height/2);
    gameState.obstacles.splice(i,1);
    return true;
    }

    } else {
    // Stationary obstacles (robotbox, popupad): test each puppet hitbox
    const obstBox = getObstaclePhysicsBox(obs);
    let collided = false;
    let collidedHitBox = null;
    for (let hb of hitBoxes) {
    if (rectsOverlap(hb, obstBox)) { collided = true; collidedHitBox = hb; break; }
    }
    if (collided) {
    createExplosion(collidedHitBox.x + collidedHitBox.width/2, collidedHitBox.y + collidedHitBox.height/2);
    return true;
    }
    }
  }
  return false;
}

/* ==== 
   Game main loop
   ==== */
function gameLoop(){
  if (gameState.over) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);

  if (gameState.player.pulling) gameState.player.velocity = gameState.pullStrength;
  else gameState.player.velocity += gameState.gravity;
  gameState.player.y += gameState.player.velocity;

  drawRope();
  drawPlayer();

  gameState.elapsedTime = (Date.now() - gameState.startTime)/1000;
  gameState.score = gameState.elapsedTime * 10;

  gameState.obstacleTimer++;
  const spawnInterval = 60 + Math.random()*40;
  if (gameState.obstacleTimer > spawnInterval) {
    // After 12s, with 15% chance spawn robotbox+popup on same vertical plane (same spawn tick)
    if (gameState.elapsedTime >= 12 && Math.random() < 0.15) {
    const rb = generateRobotBoxObstacle();
    const pu = generatePopUpAdObstacle();
    const planeX = canvas.width;
    rb.x = planeX;
    pu.x = planeX;
    rb.width = rb.height = 60;
    pu.width = pu.height = Math.round(80 * 0.9);

    if (!(rb.y + rb.height <= pu.y || pu.y + pu.height <= rb.y)) {
    let newY = pu.y + pu.height + 6;
    if (newY + rb.height <= canvas.height) {
    rb.y = newY;
    } else {
    newY = pu.y - rb.height - 6;
    rb.y = Math.max(0, newY);
    }
    rb.y = Math.max(0, Math.min(canvas.height - rb.height, rb.y));
    }

    // recompute tight boxes after sizes are overridden
    const tbRb = computeTightBoundsForImageAtSize(robotBoxImage, rb.width, rb.height);
    if (tbRb) rb._tightBox = tbRb;
    const tbPu = computeTightBoundsForImageAtSize(popUpAdImage, pu.width, pu.height);
    if (tbPu) pu._tightBox = tbPu;

    gameState.obstacles.push(rb);
    gameState.obstacles.push(pu);
    } else {
    if (Math.random()<0.5) gameState.obstacles.push(generateRobotBoxObstacle());
    else gameState.obstacles.push(generatePopUpAdObstacle());
    }
    gameState.obstacleTimer = 0;
  }

  // ASTERISK spawn (starts at 16s)
  if (gameState.elapsedTime >= 16) {
    if (!gameState.asteriskSpawnStarted) {
    let a = generateAsteriskObstacle();
    const pb0 = getAsteriskPhysicsBox(a);
    const fullyInsideAtSpawn = (pb0.x >= ENTERED_MARGIN && pb0.x + pb0.width <= canvas.width - ENTERED_MARGIN && pb0.y >= ENTERED_MARGIN && pb0.y + pb0.height <= canvas.height - ENTERED_MARGIN);
    if (fullyInsideAtSpawn) a.entered = true;
    gameState.obstacles.push(a);
    liveAsteriskRef = a;
    gameState.asteriskSpawnStarted = true;
    gameState.asteriskTimer = 0;
    }

    gameState.asteriskTimer++;
    const timeSinceA = Math.max(gameState.elapsedTime - 16, 0);
    const ramp=60, startI=160, endI=40, prog = Math.min(timeSinceA / ramp, 1);
    const aInterval = Math.round(startI + (endI - startI) * prog);
    if (gameState.asteriskTimer >= aInterval) {
    const a = generateAsteriskObstacle();
    gameState.obstacles.push(a);
    liveAsteriskRef = a;
    gameState.asteriskTimer = 0;
    }
  }

  // SPAMTON spawn (starts at 24s)
  if (gameState.elapsedTime >= 24) {
    if (!gameState.spamtonSpawnStarted) {
    const s = generateSpamtonObstacle();
    gameState.obstacles.push(s);
    gameState.spamtonSpawnStarted = true;
    gameState.spamtonTimer = 0;
    }
    gameState.spamtonTimer++;
    const minI = 240; // doubled interval (less frequent)
    const maxI = 720;
    const elapsedFactor = Math.min(gameState.elapsedTime / 120, 1);
    const chosenInterval = Math.round(minI + (maxI - minI) * (1 - elapsedFactor) * Math.random());
    if (gameState.spamtonTimer >= chosenInterval) {
    const s = generateSpamtonObstacle();
    gameState.obstacles.push(s);
    gameState.spamtonTimer = 0;
    }
  }

  // Update & filter obstacles
  gameState.obstacles = gameState.obstacles.filter(obs=>{
    if (obs._remove) return false;

    if (obs.type==='asterisk' || obs.type==='spamton'){
    obs.x += obs.vx; obs.y += obs.vy;
    obs.age = (obs.age || 0) + 1;

    const pb = getAsteriskPhysicsBox(obs);
    const fullyInside = (pb.x >= ENTERED_MARGIN && pb.x + pb.width <= canvas.width - ENTERED_MARGIN && pb.y >= ENTERED_MARGIN && pb.y + pb.height <= canvas.height - ENTERED_MARGIN);
    if (!obs.entered && fullyInside && obs.age > ENTERED_GRACE_FRAMES) {
    obs.entered = true;
    }

    const hitEdge = obs.entered && (pb.x <= 0 || pb.x + pb.width >= canvas.width || pb.y <= 0 || pb.y + pb.height >= canvas.height);
    if (hitEdge) {
    if (liveAsteriskRef === obs) liveAsteriskRef = null;
    createExplosion(obs.x + obs.width/2, obs.y + obs.height/2);
    return false;
    }

    if (obs.x + obs.width < -150 || obs.x > canvas.width + 150 || obs.y + obs.height < -150 || obs.y > canvas.height + 150) {
    if (liveAsteriskRef === obs) liveAsteriskRef = null;
    return false;
    }

    if (obs.entered) {
    for (let other of gameState.obstacles) {
    if (other === obs) continue;
    if (other._remove) continue;

    if (other.type !== 'asterisk' && other.type !== 'spamton') {
    const otherBox = getObstaclePhysicsBox(other);
    if (pb.x < otherBox.x + otherBox.width && pb.x + pb.width > otherBox.x && pb.y < otherBox.y + otherBox.height && pb.y + pb.height > otherBox.y) {
    if (liveAsteriskRef === obs) liveAsteriskRef = null;
    createExplosion(obs.x + obs.width/2, obs.y + obs.height/2);
    return false;
    }
    continue;
    }

    if (other.type === 'asterisk' || other.type === 'spamton') {
    const pbOther = getAsteriskPhysicsBox(other);
    if (rectsOverlap(pb, pbOther)) {
    other._remove = true;
    createExplosion(obs.x + obs.width/2, obs.y + obs.height/2);
    createExplosion(other.x + other.width/2, other.y + other.height/2);
    if (liveAsteriskRef === obs) liveAsteriskRef = null;
    if (liveAsteriskRef === other) liveAsteriskRef = null;
    return false;
    }
    }
    }
    }

    return true;
    } else {
    obs.x -= gameState.gameSpeed;
    return obs.x + obs.width > 0;
    }
  });

  drawObstacles();
  drawExplosions();

  if (checkCollision()) { endGame(); return; }

  ctx.fillStyle = '#FFF'; ctx.font = 'bold 20px monospace';
  ctx.fillText(`Score: ${Math.floor(gameState.score)}`, 10, 30);
  ctx.fillText(`Time: ${Math.floor(gameState.elapsedTime)}s`, 10, 55);
  ctx.fillText(`Level: ${gameState.difficultyLevel + 1}`, 10, 80);

  requestAnimationFrame(gameLoop);
}

/* ==== 
   Start / End game (unchanged except overlay removal added)
   ==== */
function startGame(){
  if (!imageLoaded) { alert('Please wait for images to load'); return; }
  // remove any game over overlay if present
  removeGameOverOverlay();

  gameState = {
    started:true, over:false,
    player:{ x:100,y:200,width:80,height:80,velocity:0,pulling:false },
    obstacles:[], explosions:[], score:0,
    highScore: localStorage.getItem('puppetFlyerHighScore') || 0,
    gameSpeed:8, gravity:0.4, pullStrength:-7,
    obstacleTimer:0, asteriskTimer:0, asteriskSpawnStarted:false,
    spinningTimer:0, spawnInterval:80, startTime:Date.now(), elapsedTime:0, difficultyLevel:0,
    spamtonTimer:0, spamtonSpawnStarted:false
  };
  liveAsteriskRef = null;
  controlsDiv.innerHTML = '';
  gameLoop();
}

function removeGameOverOverlay(){
  const existing = document.getElementById('gameOverOverlay');
  if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
}

/* Updated endGame: create a centered overlay in .game-container with smaller pixel text */
function endGame(){
  gameState.over = true;
  const finalScore = Math.floor(gameState.score);
  if (finalScore > gameState.highScore) { gameState.highScore = finalScore; localStorage.setItem('puppetFlyerHighScore', finalScore); }

  // Clear controls area (we'll show overlay centered over the game)
  controlsDiv.innerHTML = '';

  // Create (or replace) overlay inside .game-container
  const container = document.querySelector('.game-container');
  removeGameOverOverlay();
  const overlay = document.createElement('div');
  overlay.id = 'gameOverOverlay';
  overlay.className = 'game-over-overlay';

  // Use smaller pixel text:
  // - GAME OVER: chunkiness scale 4 (smaller)
  // - Score: scale 3 (slightly smaller)
  const bigData = createPixelatedTextDataURL('GAME OVER', 4, '#0CAF0C');
  const scoreData = createPixelatedTextDataURL('Score: ' + finalScore, 3, '#0CAF0C');

  overlay.innerHTML = `
    <div style="display:flex;flex-direction:column;align-items:center;gap:6px">
      <img src="${bigData}" alt="GAME OVER" />
      <img src="${scoreData}" alt="Score" />
    </div>
    <div style="margin-top:6px"><button id="replayBtn">PLAY AGAIN</button></div>
  `;
  container.appendChild(overlay);

  // Wire replay button: remove overlay and start countdown -> startGame
  const replayBtn = document.getElementById('replayBtn');
  if (replayBtn) {
    replayBtn.addEventListener('click', () => {
      removeGameOverOverlay();
      startGameWithCountdown();
    });
  }
}

/* ==== 
   Input handlers (unchanged)
   ==== */
window.addEventListener('keydown', e => { if (e.code==='Space' && gameState.started && !gameState.over) { e.preventDefault(); gameState.player.pulling = true; }});
window.addEventListener('keyup', e => { if (e.code==='Space') { e.preventDefault(); gameState.player.pulling = false; }});
canvas.addEventListener('mousedown', e => { if (gameState.started && !gameState.over) { e.preventDefault(); gameState.player.pulling = true; }});
canvas.addEventListener('mouseup', e => { e.preventDefault(); gameState.player.pulling = false; });
canvas.addEventListener('touchstart', e => { if (gameState.started && !gameState.over) { e.preventDefault(); e.stopPropagation(); gameState.player.pulling = true; } }, { passive:false });
canvas.addEventListener('touchend', e => { e.preventDefault(); e.stopPropagation(); gameState.player.pulling = false; }, { passive:false });

/* ==== 
   Removed: debug UI wiring, debug overlay, auth/leaderboard functions & init.
   The game retains collision, hitbox config and image tight-box logic.
   No auth or debug UI code runs.
   ==== */

/* ===== Pixelated text helper (unchanged) ===== */
function createPixelatedTextDataURL(text, scale = 6, color = '#0CAF0C') {
  const baseFontSize = 12;
  const font = `bold ${baseFontSize}px monospace`;
  const small = document.createElement('canvas');
  const sCtx = small.getContext('2d');
  sCtx.font = font;
  const metrics = sCtx.measureText(text);
  const padding = 4;
  const w = Math.ceil(metrics.width) + padding * 2;
  const h = Math.ceil(baseFontSize * 1.4) + padding * 2;
  small.width = Math.max(1, w);
  small.height = Math.max(1, h);
  const sc = small.getContext('2d');
  sc.font = font;
  sc.textBaseline = 'top';
  sc.fillStyle = color;
  sc.clearRect(0,0,small.width, small.height);
  sc.fillText(text, padding, padding);
  const final = document.createElement('canvas');
  final.width = small.width * scale;
  final.height = small.height * scale;
  const fctx = final.getContext('2d');
  fctx.imageSmoothingEnabled = false;
  fctx.clearRect(0,0, final.width, final.height);
  fctx.drawImage(small, 0, 0, small.width, small.height, 0, 0, final.width, final.height);
  return final.toDataURL();
}

/* Countdown helper (modified: explicit sizing + clear content after hide) */
function startGameWithCountdown(){
  const overlay = document.getElementById('countdownOverlay');
  const numEl = document.getElementById('countdownNumber');
  if (!overlay || !numEl) { startGame(); return; }

  overlay.style.display = 'flex';
  overlay.setAttribute('aria-hidden', 'false');

  const values = ['3','2','1'];
  let i = 0;

  function setPixelContent(container, imgSrc) {
    container.innerHTML = '';
    const img = new Image();
    img.src = imgSrc;
    img.alt = container.textContent || '';
    img.style.display = 'block';
    img.style.maxWidth = '100%';
    img.style.maxHeight = '100%';
    container.appendChild(img);
  }

  function showNext(){
    if (i < values.length) {
    const dataUrl = createPixelatedTextDataURL(values[i], 8, '#0CAF0C');
    setPixelContent(numEl, dataUrl);

    numEl.classList.remove('show');
    void numEl.offsetWidth;
    numEl.classList.add('show');
    i++;
    setTimeout(() => {
    numEl.classList.remove('show');
    setTimeout(showNext, 220);
    }, 720);
    } else {
    const goUrl = createPixelatedTextDataURL('GO!', 7, '#3AFF6B');
    setPixelContent(numEl, goUrl);

    numEl.classList.add('show');
    setTimeout(() => {
    numEl.classList.remove('show');
    overlay.style.display = 'none';
    overlay.setAttribute('aria-hidden', 'true');
    // clear the image nodes from countdown element so it won't persist
    numEl.innerHTML = '';
    // call original start
    startGame();
    }, 420);
    }
  }
  showNext();
}

</script>

</body>
</html>